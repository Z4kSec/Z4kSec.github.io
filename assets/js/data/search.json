[ { "title": "IoctlHunter Release (v0.2)", "url": "/posts/ioctlhunter-release-v0.2/", "categories": "Tools", "tags": "ioctlhunter, ioctl, drivers, pentest, reverse, frida", "date": "2023-12-07 00:00:00 +0000", "snippet": "A Bit of ContextIoctlHunter is a command-line tool designed to simplify the analysis of IOCTL calls made by userland software targeting Windows drivers.TL;DR: Here are the videos demonstrating the ...", "content": "A Bit of ContextIoctlHunter is a command-line tool designed to simplify the analysis of IOCTL calls made by userland software targeting Windows drivers.TL;DR: Here are the videos demonstrating the usage of IoctlHunterFrom a cybersecurity perspective, IoctlHunter empowers security researchers to identify IOCTL calls that could potentially be reused in standalone binaries to perform various actions, such as privilege escalation (EoP) or killing Endpoint Detection and Response (EDR) processes.This technique, also known as BYOVD (Bring Your Own Vulnerable Driver), involves embedding a signed vulnerable driver within a binary. Once deployed on a targeted system, the binary loads the driver and sends IOCTL calls to it to execute specific offensive actions with kernel-level privileges.This article was written in continuity of a blog post written by Alice. In this awesome article, Alice explains how it is possible to perform a static analysis of Windows drivers to retrieve features allowing a userland software to kill protected processes such as EDR ones.While reading it, it definitely challenged me to build a tool that enables lazy reverse engineers to easily discover drivers providing juicy features for offensive use cases.We will not deep dive into how drivers work or describe all their interactions with userland processes in detail. Thus, I strongly recommend reading Alice’s blog post to gain a deep understanding of how drivers work and how to exploit them.However, before understanding how IoctlHunter works, let me introduce a few key concepts.Driver LoadingFirst, drivers must be loaded on the running Windows system. This can be achieved by running the following command lines:$&gt; sc.exe create MyDriver binPath= C:\\windows\\temp\\MyDriver.sys type= kernel$&gt; sc.exe start MyDriverAs you can see, the load of a driver consist in starting a service. Thus, the same result can be achieved by performing the following steps: Create a registry path within HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MyDriver (see. the function RegCreateKeyExW from Advapi32.dll) Set multiple registry key within it including the ImagePath which is a string pointing to the absolute file path where the driver binary is stored on the disk (see. the function RegSetValueExA from Advapi32.dll) Start the service and load the driver by specifying the newly created registry path (see. the function NtLoadDriver from ntdll.dll)Once your driver successfully loaded, you will need to open a handle on it to interact with it. This can be achieved by calling function such as CreateFileA The tool Backstab, developed in C++ by Yasser, provide a very nice implementation of arbitrary driver loading and unloading there: Driverloading.cRun kernel land codeOnce you obtain a handle on your loaded driver, you are now able to send instruction to it. Indeed, drivers can exposed specific functions to be run on the kernel side.In order to specify which function must be executed, userland programs can send the IOCTL (I/O control code). This 32 bits value is bascically dedicated to indicate to the driver which function must be called by within the drivers code.The DeviceIoControl function (see. MS documentation) provides this interface between user land programs and the driver code running in the kernel side.Few parameters are required to do the stuff: A handle to the targeted driver (hDevice) The transmitted IOCTL code (dwIoControlCode) The associated transmitted data (lpInBuffer) and its size (nInBufferSize) The returned data (lpOutBuffer, nOutBufferSize)Some examples of interesting IOCTL calls involve transmitting basic data in the lpInBuffer parameter, such as an integer specifying a process to be terminated. However, the typical usage of DeviceIoControl often requires submitting a custom C-like structure in this parameter, containing various data types. Understanding how to construct such a structure may necessitate static analysis of the driver.In such case, a good approach is first to identify the IOCTl code related to the function that we are intersting in. Then, with a reverse software like cutter, ghidra or IDA, we can start by looking for the Driver main function and browse the code until we found “a switch case” pattern were the dispatching between all IOCTL codes is made between all driver implemented functions (not always the case!).Alice's example of switch case dispatching IOCTL code on a driver sideFinally, once a static comparison between our IOCTL code is made, we are not that far of the paramater containing the lpInBuffer pointer. If you look for data pointed by it, you should be able to analyse the provided structure.Chain itAs we’ve discussed, multiple calls can be intercepted to dynamically retrieve drivers loaded by a program based on changes to registry keys.Moreover, DeviceIoControl calls contain sufficient information to help us retrieve the portion of driver code that will be executed, the data sent as parameters to perform tasks, and the size of this data.In short, from a “user land” perspective, a security researcher can intercept all the previously mentioned Win32 functions to dynamically obtain the following information: Automatically detect loaded drivers. Intercept IOCTL calls and the associated data. Retrieve the driver using the handle passed as a parameter to DeviceIoControl.With this information, you can extract necessary data in a lab while analyzing a tool with a driver capable of executing kernel-level actions for offensive purposes.Once you’ve gathered all this information by intercepting these functions or by statically reversing the driver, you’ll have everything needed to create a binary that loads the driver and sends the correct IOCTL with the appropriate data.However, in real world scenarios, multiple drivers can be dynamically loaded and called by a single executable. This can make it challenging, with the hooking approach, to identify the IOCTLs that match the observed features while using tools not specifically designed for this purpose. That’s why I began developing IoctlHunter.Ease the process with IoctlHunterUnlike some of today’s tools, IoctlHunter differs from static driver analysis approaches. The tool aim is to execute a binary that is likely reliant on drivers providing interesting offensive features. By exploring the various options presented by such programs, IoctlHunter helps in monitoring the IOCTL calls that occured.The mindset to adopt when using IoctlHunter is a bit like using BurpSuite to analyze a website. You navigate to the options that might interest you and look in IoctlHunter for the potential associated IOCTL.The tool provides several essential pieces of information to replay an IOCTL, thanks to the DeviceIoControl function (see MS documentation): The target driver The transmitted IOCTL code (dwIoControlCode) The associated transmitted data (lpInBuffer) and its size (nInBufferSize) The returned data (lpOutBuffer, nOutBufferSize)With this information, it is possible to conduct a static analysis of the driver to scrutinize the associated code in detail, starting from the IOCTL code. However, it is also possible to directly replay this IOCTL call if its usage appears straightforward.Detection of a dynamically loaded driverIoctlHunter output providing \"dwIoControlCode\" and hexdump of the \"lpInBuffer\" dataSuccessful use of IoctlHunter empowers Red Teamers and Penetration Testers to create a standalone executable that installs a specific driver and issues one or more IOCTL calls to perform various tasks. The advantage lies in the ability to execute signed drivers with kernel privileges, and to exploit useful features in an offensive way.Obviously such standalone BYOVD binaries requires the SeLoadDriverPrivilege flags to be able to do the magic!How it works?As IoctlHunter base its analysis on hooking, I decided to use the most advanced and easily scriptable tool to do this job: Frida. Frida is basically a dynamic instrumentation tool which support Python to script with. Its main usage consists in injecting code into a process and to hook functions within running processes, facilitating a debugging, as well as reverse engineering. I am sure lots of you already used it for mobile pentests (certificate pinning bypass FTW!) or to easily reverse thick clients.From this awesome libraries, IoctlHunter is able to spawn or attach to an existing process to be analyse. Then, a RPC communication is established between the two process and IoctlHunter is able to hook useful functions in order to collect all IOCTL calls, apply fynamic filters on them and much more!The full developped Frida script can be found there: script.tsDemo with PowerToolsIn Alice’s blog post, titled “Finding and Exploiting Process Killer Drivers with LOL for $3000,” she demonstrated how a static reverse engineering analysis of the kEvP64.sys driver used by the PowerTool software allowed her to develop a process killer tool that could terminate protected processes with kernel-level privileges.The following video demonstrates how IoctlHunter makes it easy to identify all the elements needed to terminate protected processes using the same tool:Hunting for IOCTLs on PowerToolSubsequently, using the information obtained, a Golang package provided in the IoctlHunter repository allows you to load and replay the IOCTL calls:Killing protected processes thanks to PowerTool driverLimitiationsIt is important to underline that IoctlHunter is not designed to supplant traditional static or dynamic reverse engineering methods used for vulnerability discovery in drivers. Instead, it serves as a complementary tool to help in the dynamic identification of specific IOCTL calls information, providing additional insights into the behavior of drivers loaded by a given software. As describe in this article, the complexity resides in the identification of the data structure linked to the lpInBuffer data buffer.Furthermore, the tool primarily involves injecting itself into processes for analysis. However, this approach may not work directly when targeting processes are protected with anti-tampering mechanisms. For instance, EDR (Endpoint Detection and Response) processes may not allow injection via Frida without the prior use of a specific driver to open a handle on these protected processes. IoctlHunter is designed to gather IOCTL data in a controlled lab environment. This enables the disabling of security mechanisms and the utilization of existing techniques to inject into protected processes.Finally, the actual version of IoctlHunter allows for hooking various functions within the Windows API that have multiple implementations and/or function prototypes (see blue box on the screenshot below). This diversity arises from the existence of functions suffixed with either ‘W’ or ‘A’, with ‘W’ denoting wide-character (Unicode) and ‘A’ for ANSI character functions, depending on the string encoding used. Additionally, some functions may have ‘Ex’ suffixed, which generally indicates an extended version of the function with additional features or parameters.Furthermore, certain functions may be prefixed with ‘Nt’ or ‘Zw’, signifying native API calls that interact more directly with the operating system’s kernel. However, these functions ultimately call each other, and not every program necessarily calls the same function (see green box on the screenshot below). IoctlHunter is designed to hook the most common functions by default to avoid duplication. In cases where it’s necessary, the --all-symbols option allows for hooking all ‘versions’ of a function but may result in duplicate function calls.Hooked functions with FridaWhat’s next?First, it could be interesting to facilitate the ability to replay IOCTL calls. When the --output parameter is enabled, the generated file contains a base64 encoded buffer in the data provided through the lpInBuffer parameter of the DeviceIoControl function. It might be cool to introduce a feature that allows the replay of such IOCTL calls on the same driver for debugging purposes.The second point of improvement is not directly related to IoctlHunter. Instead, it concerns the project Loldrivers.io created this year by The Haag, which provides an extensive database of known vulnerable drivers. This database serves as an excellent starting point for identifying IOCTL vulnerabilities in BYOVD (Bring Your Own Vulnerable Driver) attacks (see Alice’s tool LOLDrivers_finder).However, the Loldrivers project does not offer detailed information regarding specific vulnerable features or how to exploit them (IOCTL codes, required input data, etc.). Obviously, the collection of this information typically involves significant reverse engineering work. Still, it might be beneficial to reference such details when available, similar to how it’s done for PowerTools, ProcExp512, RTCore64, and other vulnerable drivers. This could assist in the development of tools for drivers already known to be vulnerable (and potentially blacklisted by Microsoft). Additionally, it might contribute to the creation of more precise detection rules based on EDR telemetry (not tested!)Acknowledgements Alice for her blog post and tools regarding drivers The Haag for the Loldrivers.io project Yasser for the tool Backstab The Microsoft and Frida documentations" }, { "title": "Masky release (v0.0.3)", "url": "/posts/masky-release-v0.0.3/", "categories": "Tools", "tags": "masky, adcs, tool, dump, AD, pentest, lsass, certificates", "date": "2022-08-19 00:00:00 +0000", "snippet": "Masky is a python library providing an alternative way to remotely dump domain users’ credentials thanks to an ADCS. A command line tool has been built on top of this library in order to easily har...", "content": "Masky is a python library providing an alternative way to remotely dump domain users’ credentials thanks to an ADCS. A command line tool has been built on top of this library in order to easily harvest PFX, NT hashes and TGT on a larger scope.This tool does not exploit any new vulnerability and does not work by dumping the LSASS process memory. Indeed, it only takes advantage of legitimate Windows and Active Directory features (token impersonation, certificate authentication via kerberos and NT hashes retrieval via PKINIT). The aim of this blog post is to detail the implemented techniques and how Masky works.Masky source code is largely based on the amazing Certify and Certipy tools. I really thank their authors for the researches regarding offensive exploitation techniques against ADCS (see. Acknowledgments section). Why another tool?Redteaming or internal pentesting engagement in Active Directory environments involves the ability to move laterally between systems in order to takeover domain user accounts. There are many ways to compromise domain accounts, increasingly privileged, to eventually become domain administrator. One of the most common strategies is to compromise a system, to elevate its privileges to local administrator and to dump plaintext passwords, NT hashes or TGT from the LSASS process memory. Then, lateral movements via these users’ secrets (PtH, PtT, OPtH, etc.) usually allow to escalate its privileges on the domain by moving from a system to another.Once a system has been compromised and that you get an acceptable way to execute remote commands, one of the first question you probably think about is “which user am I going to compromise from the LSASS process memory?”. And you are right! Despite all the work perform by system and network administrators to harden the LAN (e.g. by implementing a tier model, by flushing users’ sessions or by applying strong network segmentation on administrative services like WinRM, SMB, WMI, RDP), this attacking methodology is still generally effective. Other methods to harvest domain credentials, through for instance the DPAPI, could be applied on a compromised system. However, we will not discuss them in this article because they are not directly related to interactive users’ sessions running on each system.The success of this attacking strategy has been supported by the development of tools allowing, among lots of other features, to dump and parse the LSASS process. The purpose of these tools is to retrieve NT hashes and TGT of domain users’ sessions. Tools such as Mimikatz, that we no longer present, allows to perform this task. For less detection reasons, as well as for more convenience, amazing tools like Lsassy were created to remotely dump the LSASS process via multiple techniques (procdump, nanodump, edrsandblast, etc.) and to parse it locally. This kind of tool also provides to pentester the ability to perform these remote dump through the administrative services that could be exposed by Windows systems, thanks to the impacket python library (e.g. WinRM, SMB, WMI). It basically consists in pushing an executable file, running it via for example the creation of a service or a schedule task and to retrieve the output. Moreover, such tool are now integrated into offensive Active Directory oriented toolbox, like CrackMapExec, which offer orchestration capabilities to easily attack large environments.However, the dump of the LSASS process memory is not always trivial as it was. Most recent Windows versions now implement security mechanisms such as protected process and Credential Guard. In short words, Protected Process Light (RunAsPPL) restricts the access to the LSASS process to only digitally signed and trusted process. Regarding Credential Guard, this feature basically allows to store the users’ secrets within a separate virtual machine. Additionnaly, companies now rely on the deployment of EDR (Endpoint Detection and Response) or EPP (Endpoint Protection Platform) that can hook Win32API functions allowing to read the memory of a process (OpenProcess, CreateRemoteThread, etc.). These security solutions also scan for known malicious binaries or detect attacker behaviours from usual patterns (static or dynamic analysis).Although no security solution is foolproof (e.g. kernel land bypasses with signed drivers, RIP PPLDump, SysWhisperer for function hooking, etc.), pentesters may have encoutered difficulties to bypass them from a black box point of view! Therefore, I thought about how to automate other known techniques together in order to avoid harvesting domain users’ secrets only from the LSASS process memory. The aim of this article is not to describe the LSASS dump functionning, the available countermeasures or to detail how these amazing quoted tools and bypasses works. There are plenty of articles that describe it way better than me!ADCS for the winThe last years were rich in terms of vulnerabilities helping to takeover a domain. However, I recently had a special focus on the ADCS attack path (Active Directory Certificate Services) thanks to the Certified Pre-Owned paper written by Will Schroeder (@harmj0y) and Lee Christensen (@tifkin_). The differents privilege escalation and persistence techniques based on a PKI implemented via this Microsoft solution offer a really interesting attack surface (e.g. NTLM relay to web enrollement, vulnerable templates exploitation, etc.). In addition to this ressource, I also read the articles written by Oliver Lyak (@Ly4k) on this subject and especially the one regarding the Certifried vulnerability (CVE-2022–26923).We will not deep dive into how works an ADCS or how its misconfiguration could be exploited. However, it is necessary to understand that such PKI implementation is directly linked to the Active Directory forest where it is deployed and provides, among other features, the ability to authenticate domain users based on certificates.From all of the information in these articles, two concepts caught my attention: A domain user can request a certificate to a CA server by using, for instance, the User template (implemented by default); A user certificate can be used to authenticate on the KDC via the PKINIT (kerberos extension).Before we think about exploiting these behaviors, it is important to understand how we can obtain a certificate from the ADCS. First, a domain user can query a CA server to enroll for a certificate, based on a specific template. This enrollement consists in generating a public and private keys in the user’s context. Then, a certificate signing request (CSR), including the public key and the targeted template name, is sent to the CA server. A set of domain checks is performed by the ADCS with the domain controller, based on the requesting domain user. If it succeed, a certificate is generated base on the chosen template. This certificate is finally signed with its CA server private key and returned to the user (PEM format that can be converted in PFX).Certificate enrollement schema from the \"Certified Pre-Owned\" articleThis is a very simplified explaination of the ADCS enrollement process. Nevertheless, from an offensive point of view, this mechanism allows an attacker who can execute code in a targeted user context to query a certificate allowing to authenticate on the domain.Indeed, a certificate queried for example from the User template can be reused to authenticate via the Kerberos procotol. Basically, the user will use the signed certificate to request a TGT from the KDC. The Active Directory can be requested for such authentication thanks to the PKINIT Kerberos extension (Public Key Cryptography for Initial Authentication).In addition to the obtained TGT, the PKINIT protocol allows to retrieve the NT hash of the requesting user. This technique is identified as THEFT5 within the Certified Pre-Owned paper and was first published on twitter by Benjamin Delpy (@gentilkiwi). This offensive abuse is due to a fallback feature implemented within the PKINIT protocol. From this built-in feature, the NT hash can be retrieved from the obtained TGT (see. UnPAC the hash). The aim of it was to allow the user to authenticate on systems or applications that only support legacy authentication.If we sum-up a little bit all this information, an attacker able to execute code within its target context can query a certificate to the ADCS and then authenticate on the KDC. Thus, an attacker is able to retrieve a TGT as well as the NT hash in plaintext for each targeted users. Is that not really nice? :)During pentesting and redteaming engagements, many post exploitation scenarios can be done with the use of these legitimate Microsoft mechanisms.Imagine that you are local administrator on a server with a running domain administrator session on it. For some reason you cannot dump the LSASS process memory. However, from the RDP session you can hijack its session via, for example, the tscon utility and then request a certificate through the User template. The Certify tool can be used to easily retrieve a valid PEM certificate. Once converted with openssl to a PFX, you can use it with Kekeo, Rubeus or Certipy to authenticate via PKINIT, retrieve a TGT and then the user’s NT hash. Session hijacking via Certify and Tscon toolsThis method relies on legit features and allows to compromise a domain user without touching LSASS on a stealthier way (take care of the Certify binary detection). However, this technique was performed manually via an interactive session through RDP. This remains harder to be automated on a larger scope as the Lsassy / CME tools do by dumping the LSASS process memory through SMB.After few attempts to develop a tool automating the usage of tscon and Certify via a “ducky script like strategy” (really bad idea btw), I thought about a way to impersonate on a large scale the users’ sessions that were not properly logged off on the remote servers.The Windows token mechanisms came to my mind and in particular the use of the Incognito tool. Indeed, from an attacker point of view who is local administrator on a system, a privilege escalation could be perform to become NT AUTHORITY/SYSTEM (for instance via a service creation as PSEXEC do). Then, from this privileged access, all running processes on the compromised system can be browsed in order to open the one related to our targeted domain user. Once the process is opened, its associated access tokens can be duplicated and re-used to hijack the user session.The advantage of this technique is that it automates the process of impersonating users and execute arbitrary code within their context. The following demo shows how it is possible, from a meterpreter session, to easily switch from one user context to another. Demo of users' sessions switching via Incognito through token impersonationMcAfee’s security team made a very interesting article about the theft and manipulation of these access tokens. In a nutshell, when a user logs on to a Windows system, a session represented by a Security Identifier (SID) is created. Moreover, an access token is generated by the Local Security Authority (LSA) and is associated with the user’s session. This token is used to describe the security context and privileges of the actual user (groups, etc.). Each process derived from the user’s session inherit of this access token. This allows the system to apply the correct restriction or authorization on the system for a running process (using primary token) or a thread (using impersonation token). Each of these tokens can have different impersonation levels describing the actions that can be performed in the user’s context. The SecurityDelegation is especially useful because it allows to impersonate the user through the network, meaning that ADCS interactions could be performed.This is once again a topic that would need tons of explaination to be fully covered. But, this mechanism answer to our actual need. Indeed, we are able to fully impersonate domain users’ authenticated on a compromised server, to request a certificate in their context and so to obtain for each of them a TGT and a NT hash. While writting this article a new release (4.0) of Certipy was made by Ly4k. From lots of new interesting features, the SSPI option was implemented. This allows to use the current user context on a Windows system to take advantage of the other modules without knowing the current user credentials.Putting it all togetherWe now have all the elements in our hands! Based on all of these notions, I developed a tool called Masky that automates this process and works like Lsassy does. This tool is composed of a Python part running on the attacker’s system and an executable agent in C# deployed on targeted systems.The following schema describes the implemented steps for a targeted host.Overview of the Masky operating modeStep 1 - Deploy and run Masky agentFirst, the attacker must own a user with local administrator privileges on the targeted systems. Masky supports plaintext password, NT hashes or Kerberos authentication with a loaded CCACHE file. In case of the exposure of the tcp port 445, an SMB connection is established.This SMB session allows to push a Masky agent executable into the Windows Temp folder. Once successfuly pushed via the C$ remote share, the ImagePath attribute related to the existing RasAuto service is modified to point on the Masky agent. I chose this method as it is stealthiest to modify an existing service property rather than creating a new one that will be deleted later. This remote code execution method was implemented by Pixis in Lsassy based on the @Cyb3rSn0rlax idea. The RasAuto service was chosen because it is started manually and is deployed by default from older Windows versions to newer ones.Finally, the modified service is started via the DCERPC Impacket implementation (SCMR) and the Masky agent is launched with NT AUTHORITY/SYSTEM privileges.Steps 2 and 3 - Query ADCS for certificatesThis binary, developed in C#, aims to browse all running processes. For each of them, it performs some checks like what kind of process it is or who is the owner. Then, the process is opened with the OpenProcessToken function to retrieve the associated access tokens. The tokens are duplicated with the DuplicateTokenEx function and finally the current impersonation token of the Masky agent main thread is replaced by the spoofed one with a call to SetThreadToken. These functions are members of the Win32API, their prototypes can be easily retrieved from the Pinvoke website to be used in C#.For each spoofed user, an asymmetric key pair is generated and a CSR requesting the User template is sent to the CA server. This implementation is entirely based on the Certify tool. The PEM certificate is retrieved and appended within a JSON file with the spoofed username. The Masky agent switch between users by storing its initial access token and restoring it. This avoids to spawn processes or threads to perform this task.Masky automatically downloads the generated JSON file through SMB as well as a debugging file (in case of a stacktrace). Finally, all files are deleted from the remote server and the RasAuto original ImagePath is restored.Step 4 - Retrieve users’ secrets from downloaded certificatesThe next steps are performed from the local attacker’s system. Indeed, the collected PEM certificates are converted into PFX format and a TGT is requested to the KDC via the PKINIT Kerberos implementation. This TGT is exported in the CCACHE format to be easily loaded on Linux systems (via the command line: export KRB5CCNAME=./file.ccache). Then, a NT hash is retrieved through the PKINIT fallback feature. All of these KDC interactions came from the tools Certipy and PKINITTools (developed by Dirk-jan Mollema). Only minors modifications were made from the original Certipy modules in order to do this job!This overall process is replicated on each targeted system to store locally the NT hashes, CCACHE and PFX files. All of this allowing to perform further Pass-The-(hash,ticket,certificate) lateral movements! :)Masky for fun and profitMasky version 0.0.3 was released besides this article on my github: https://github.com/Z4kSec/Masky. This version might be “unstable” and special care should be taken while using it to ensure that the RasAuto ImagePath has been correctly restored on the targeted system, in case of an unexpected crash. This should not occured of course, but we never anticipate all behaviors! ;)Because a demo is sometimes more effective than lots of words, please find below an example of its use. Masky demo on a testing labNote that the FQDN of the CA server and the CA names must be provided to the tool. The User template must also be enabled on it. This information can be easily retrieved with the find Certipy commands as well as via the certutil.exe Microsoft utility.All parameters and their usage are described within the Masky Github readme. Moreover, the tool can be used as a library to be integrated within other tools.Below is a simple script using the Masky library to collect secrets of running domain user’s sessions, from a remote target.from masky import Maskyfrom getpass import getpassdef dump_nt_hashes(): # Define the authentication parameters ca = \"srv-01.sec.lab\\sec-SRV-01-CA\" dc_ip = \"192.168.23.148\" domain = \"sec.lab\" user = \"askywalker\" password = getpass() # Create a Masky instance with these credentials m = Masky(ca=ca, user=user, dc_ip=dc_ip, domain=domain, password=password) # Set a target and run Masky against it target = \"192.168.23.130\" rslts = m.run(target) # Check if Masky succesfully hijacked at least a user session # or if an unexpected error occured if not rslts: return False # Loop on MaskyResult object to display hijacked users and to retreive their NT hashes print(f\"Results from hostname: {rslts.hostname}\") for user in rslts.users: print(f\"\\t - {user.domain}\\{user.name} - {user.nt_hash}\") return Trueif __name__ == \"__main__\": dump_nt_hashes()This generates the following output once executed on my testing lab.$&gt; python3 ./masky_demo.pyPassword:Results from hostname: SRV-01 - sec\\hsolo - 05ff4b2d523bc5c21e195e9851e2b157 - sec\\askywalker - 8928e0723012a8471c0084149c4e23b1 - sec\\administrator - 4f1c6b554bb79e2ce91e012ffbe6988aA MaskyResults object containing a list of User objects is returned after a successful execution of Masky.Please look at the masky\\lib\\results.py module to check the methods and attributes provided by these two classes.Detection vectorsFrom a blueteam perspective, several behaviors can be detected when exploiting such attack path.First of all, Masky heavily relies on the SMB protocol to execute remote code on the target, but also to deploy the agent and retrieves the results.Offensive tools relying on this protocol typically interact with three shares: C$, ADMIN$ and IPC$. Wherever the C$ and ADMIN$ shares are mounted as local administrator and are used to push or retrieve files, the IPC$ is related to the usage of named pipes exposed by the remote system. It basically allows to interact with the features exposed on the target through legitimate protocols. Indeed, the DCERPC protocol allows, as it names suggest, to call remote procedures allowing for example to create services (via \\pipe\\svcctl) or scheduled tasks (via \\pipe\\atsvc). I strongly recommend diving into Impacket source code and especially their example scripts to understand how it works (smbexec.py, atexec.py, etc.).From this information, the following Windows event log IDs can be collected on your SIEM to create detection rules for such remote code execution over SMB: 4698: A schedule task was created; 4699: A schedule task was deleted; 4702: A schedule task was updated; 7045: A new service was created; 5145: A network share object (file or folder) was accessed.The use of service or schedule tasks in a short period of time (e.g. creation, modification or deletion) could be an interesting weak signal to correlate with administrative shares interactions (C$ / ADMIN$), as well as the IPC$ special share. Indeed, this could be a sign of the use of such lateral movement techniques. False positives can occur based on these rules depending on the administration tools used through the corporate LAN (e.g. PSEXEC). To go deeper in such detection, rules can be combined to identify the spawning of suspicious lolbins, unsigned binaries or commonly executed recognition commands (e.g. whoami, net user, etc.) from the process tree of the schtasks.exe (schedule tasks) or winexesvc.exe (services) processes.Once the lateral movement detection is monitored, the behaviors related to the locally deployed agent has to be handled.The token impersonation part may be difficult to be detected due to the usage of legitimate built-in Microsoft Win32API functions. The McAfee’s article includes a diagram that sum-up the call of such functions during a token impersonation attempts.McAfee's schema which sum-up the functions involved in token impersonation attackIn Masky case, the OpenProcessToken, DuplicateTokenEx and SetThreadToken are primarily used to perform session hijacking on active users. A Yara rule dedicated to the detection of malwares relying on such Win32API functions was written within the quoted McAfee article and could be a good start. Note that this detection method is more related to static analaysis during incident response. Without an in-depth manual analysis, such automated detection could be bypassed by an attacker applying techniques such as obfuscation, packing, process hollowing with dynamic unxor of the payload, etc.In addition, the interaction with the ADCS instance could be an interesting way to detect Masky execution. The Certified Pre-Owned article describes detection and preventive actions that could be applied on ADCS environment. From the listed detection methods, the one referenced DETECT1 recommends to monitor the users’ certificates enrollement via the Event ID 4886 (“Certificate Services received a certificate request”) and their approval via the Event ID 4887 (“Certificate Services approved a certificate request and issued a certificate”). However, depending on the environment, the monitoring of all certificate requests could not be efficient when there is a large number of legitimate requests.A second method that could generate less false positive detection is suggested by the Specterops team. Referenced DETECT2, this detection method is based on the identification of Kerberos authentication made via a certificate, through PKINIT. Indeed, the Event ID 4768 (“A kerberos authentication ticket (TGT) was requested”) is generated on the KDC server. When a TGT is queried with a certificate, this event log contains 3 new fields in the Certificate Information section (Issuer, Serial Number and Thumbprint). Modern environments less use this protocol, and could therefore allow to detect malicious authentication attempts with a previously obtained certificate.Finally, in case of a widespread Masky usage, the deployed agent may be automatically detected via a static analysis by common EPP or EDR if used as part of the PyPi package (embedded agent executable).What’s next?First, an optimization of the token impersonation harvesting within the Masky Agent has to be done. Then, lots of debugging may be performed regarding unexpected bugs based on other environments than my lab.The published version actually includes minimal functionnalties to be used in pentesting engagements.However, I planned to implement the following features: Ability to dynamically change the modified service (default RasAuto); Option to automatically retrieve the CA server and look for the User template; Add multiple execution methods through SMB (schedule task, WMI, creation of service, etc.); Deploy the Masky agent as a XORed payload (with a random key) and dynamically load it through a svchost.exe launched process (process hollowing technique).A CrackMapExec module could also be developed if Masky has some interest for the info sec community :)Acknowledgements Olivier Lyak for the Certipy tool and the associated articles Will Schroeder and Lee Christensen for the Certify tool and the Certified Pre-Owned article Dirk-jan for the PKINITtools and its ADCS NTLM relay article SecureAuthCorp and the associated contributors for the Impacket library Pixis for the tool Lsassy Incognito tool and its Metasploit implementation S3cur3Th1sSh1t for the tool SharpImpersonation and the associated article McAfee for their article regarding the token impersonation techniques" } ]
