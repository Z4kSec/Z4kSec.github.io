<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Masky release (v0.0.3)" /><meta property="og:locale" content="en" /><meta name="description" content="Masky is a python library providing an alternative way to remotely dump domain users’ credentials thanks to an ADCS. A command line tool has been built on top of this library in order to easily harvest PFX, NT hashes and TGT on a larger scope." /><meta property="og:description" content="Masky is a python library providing an alternative way to remotely dump domain users’ credentials thanks to an ADCS. A command line tool has been built on top of this library in order to easily harvest PFX, NT hashes and TGT on a larger scope." /><link rel="canonical" href="https://z4ksec.github.io/posts/masky-release-v0.0.3/" /><meta property="og:url" content="https://z4ksec.github.io/posts/masky-release-v0.0.3/" /><meta property="og:site_name" content="Zak’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-19T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Masky release (v0.0.3)" /><meta name="twitter:site" content="@_ZakSec" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-25T12:27:58+00:00","datePublished":"2022-08-19T00:00:00+00:00","description":"Masky is a python library providing an alternative way to remotely dump domain users’ credentials thanks to an ADCS. A command line tool has been built on top of this library in order to easily harvest PFX, NT hashes and TGT on a larger scope.","headline":"Masky release (v0.0.3)","mainEntityOfPage":{"@type":"WebPage","@id":"https://z4ksec.github.io/posts/masky-release-v0.0.3/"},"url":"https://z4ksec.github.io/posts/masky-release-v0.0.3/"}</script><title>Masky release (v0.0.3) | Zak's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Zak's blog"><meta name="application-name" content="Zak's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Zak's blog</a></div><div class="site-subtitle font-italic">Pentesting and RedTeaming stuff</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Z4kSec" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/_ZakSec" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Masky release (v0.0.3)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Masky release (v0.0.3)</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1660867200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 19, 2022 </em> </span> <span> Updated <em class="" data-ts="1661430478" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 25, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/_ZakSec">Zak</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3942 words"> <em>21 min</em> read</span></div></div></div><div class="post-content"><p><a href="https://github.com/Z4kSec/Masky">Masky</a> is a python library providing an alternative way to remotely dump domain users’ credentials thanks to an ADCS. A command line tool has been built on top of this library in order to easily harvest PFX, NT hashes and TGT on a larger scope.</p><p>This tool does not exploit any new vulnerability and does not work by dumping the LSASS process memory. Indeed, it only takes advantage of legitimate Windows and Active Directory features (token impersonation, certificate authentication via kerberos and NT hashes retrieval via PKINIT). The aim of this blog post is to detail the implemented techniques and how Masky works.</p><p>Masky source code is largely based on the amazing <a href="https://github.com/GhostPack/Certify">Certify</a> and <a href="https://github.com/ly4k/Certipy">Certipy</a> tools. I really thank their authors for the researches regarding offensive exploitation techniques against ADCS (see. <a href="#acknowledgements">Acknowledgments section</a>). <br /></p><h2 id="why-another-tool"><span class="mr-2">Why another tool?</span><a href="#why-another-tool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redteaming or internal pentesting engagement in Active Directory environments involves the ability to move laterally between systems in order to takeover domain user accounts. There are many ways to compromise domain accounts, increasingly privileged, to eventually become domain administrator. One of the most common strategies is to compromise a system, to elevate its privileges to local administrator and to dump plaintext passwords, NT hashes or TGT from the LSASS process memory. Then, lateral movements via these users’ secrets (PtH, PtT, OPtH, etc.) usually allow to escalate its privileges on the domain by moving from a system to another.</p><p>Once a system has been compromised and that you get an acceptable way to execute remote commands, one of the first question you probably think about is “which user am I going to compromise from the LSASS process memory?”. And you are right! Despite all the work perform by system and network administrators to harden the LAN (e.g. by implementing a tier model, by flushing users’ sessions or by applying strong network segmentation on administrative services like WinRM, SMB, WMI, RDP), this attacking methodology is still generally effective.</p><blockquote class="prompt-tip"><p>Other methods to harvest domain credentials, through for instance the DPAPI, could be applied on a compromised system. However, we will not discuss them in this article because they are not directly related to interactive users’ sessions running on each system.</p></blockquote><p>The success of this attacking strategy has been supported by the development of tools allowing, among lots of other features, to dump and parse the LSASS process. The purpose of these tools is to retrieve NT hashes and TGT of domain users’ sessions. Tools such as Mimikatz, that we no longer present, allows to perform this task. For less detection reasons, as well as for more convenience, amazing tools like Lsassy were created to remotely dump the LSASS process via multiple techniques (procdump, nanodump, edrsandblast, etc.) and to parse it locally. This kind of tool also provides to pentester the ability to perform these remote dump through the administrative services that could be exposed by Windows systems, thanks to the impacket python library (e.g. WinRM, SMB, WMI). It basically consists in pushing an executable file, running it via for example the creation of a service or a schedule task and to retrieve the output. Moreover, such tool are now integrated into offensive Active Directory oriented toolbox, like <a href="https://github.com/Porchetta-Industries/CrackMapExec">CrackMapExec</a>, which offer orchestration capabilities to easily attack large environments.</p><p>However, the dump of the LSASS process memory is not always trivial as it was. Most recent Windows versions now implement security mechanisms such as protected process and Credential Guard. In short words, Protected Process Light (RunAsPPL) restricts the access to the LSASS process to only digitally signed and trusted process. Regarding Credential Guard, this feature basically allows to store the users’ secrets within a separate virtual machine. Additionnaly, companies now rely on the deployment of EDR (Endpoint Detection and Response) or EPP (Endpoint Protection Platform) that can hook Win32API functions allowing to read the memory of a process (OpenProcess, CreateRemoteThread, etc.). These security solutions also scan for known malicious binaries or detect attacker behaviours from usual patterns (static or dynamic analysis).</p><p>Although no security solution is foolproof (e.g. kernel land bypasses with signed drivers, RIP PPLDump, SysWhisperer for function hooking, etc.), pentesters may have encoutered difficulties to bypass them from a black box point of view! Therefore, I thought about how to automate other known techniques together in order to avoid harvesting domain users’ secrets only from the LSASS process memory.</p><blockquote class="prompt-info"><p>The aim of this article is not to describe the LSASS dump functionning, the available countermeasures or to detail how these amazing quoted tools and bypasses works. There are plenty of articles that describe it way better than me!</p></blockquote><h2 id="adcs-for-the-win"><span class="mr-2">ADCS for the win</span><a href="#adcs-for-the-win" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The last years were rich in terms of vulnerabilities helping to takeover a domain. However, I recently had a special focus on the ADCS attack path (Active Directory Certificate Services) thanks to the <a href="https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf">Certified Pre-Owned</a> paper written by Will Schroeder (<a href="https://twitter.com/harmj0y">@harmj0y</a>) and Lee Christensen (<a href="https://twitter.com/tifkin_">@tifkin_</a>). The differents privilege escalation and persistence techniques based on a PKI implemented via this Microsoft solution offer a really interesting attack surface (e.g. NTLM relay to web enrollement, vulnerable templates exploitation, etc.). In addition to this ressource, I also read the articles written by Oliver Lyak (<a href="https://twitter.com/ly4k_">@Ly4k</a>) on this subject and especially the one regarding the Certifried vulnerability (<a href="https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4">CVE-2022–26923</a>).</p><p>We will not deep dive into how works an ADCS or how its misconfiguration could be exploited. However, it is necessary to understand that such PKI implementation is directly linked to the Active Directory forest where it is deployed and provides, among other features, the ability to authenticate domain users based on certificates.</p><p>From all of the information in these articles, two concepts caught my attention:</p><ul><li>A domain user can request a certificate to a CA server by using, for instance, the <code class="language-plaintext highlighter-rouge">User template</code> (implemented by default);<li>A user certificate can be used to authenticate on the KDC via the PKINIT (kerberos extension).</ul><p>Before we think about exploiting these behaviors, it is important to understand how we can obtain a certificate from the ADCS. First, a domain user can query a CA server to enroll for a certificate, based on a specific template. This enrollement consists in generating a public and private keys in the user’s context. Then, a certificate signing request (CSR), including the public key and the targeted template name, is sent to the CA server. A set of domain checks is performed by the ADCS with the domain controller, based on the requesting domain user. If it succeed, a certificate is generated base on the chosen template. This certificate is finally signed with its CA server private key and returned to the user (PEM format that can be converted in PFX).</p><p><a href="/assets/img/cert_enrollement.png" class="popup img-link "><img data-src="/assets/img/cert_enrollement.png" alt="Certificate enrollement schema from the &quot;Certified Pre-Owned&quot; article" class="lazyload" data-proofer-ignore></a></p><center><u><i>Certificate enrollement schema from the "Certified Pre-Owned" article</i></u></center><p><br /></p><p>This is a very simplified explaination of the ADCS enrollement process. Nevertheless, from an offensive point of view, this mechanism allows an attacker who can execute code in a targeted user context to query a certificate allowing to authenticate on the domain.</p><p>Indeed, a certificate queried for example from the <code class="language-plaintext highlighter-rouge">User template</code> can be reused to authenticate via the Kerberos procotol. Basically, the user will use the signed certificate to request a TGT from the KDC. The Active Directory can be requested for such authentication thanks to the PKINIT Kerberos extension (Public Key Cryptography for Initial Authentication).</p><p>In addition to the obtained TGT, the PKINIT protocol allows to retrieve the NT hash of the requesting user. This technique is identified as <code class="language-plaintext highlighter-rouge">THEFT5</code> within the <a href="https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf">Certified Pre-Owned</a> paper and was first published on twitter by Benjamin Delpy (<a href="https://twitter.com/gentilkiwi">@gentilkiwi</a>). This offensive abuse is due to a fallback feature implemented within the PKINIT protocol. From this built-in feature, the NT hash can be retrieved from the obtained TGT (see. <a href="https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash">UnPAC the hash</a>). The aim of it was to allow the user to authenticate on systems or applications that only support legacy authentication.</p><p>If we sum-up a little bit all this information, an attacker able to execute code within its target context can query a certificate to the ADCS and then authenticate on the KDC. Thus, an attacker is able to retrieve a TGT as well as the NT hash in plaintext for each targeted users. Is that not really nice? :)</p><p>During pentesting and redteaming engagements, many post exploitation scenarios can be done with the use of these legitimate Microsoft mechanisms.</p><p>Imagine that you are local administrator on a server with a running domain administrator session on it. For some reason you cannot dump the LSASS process memory. However, from the RDP session you can hijack its session via, for example, the <a href="https://www.ired.team/offensive-security/lateral-movement/t1076-rdp-hijacking-for-lateral-movement">tscon utility</a> and then request a certificate through the <code class="language-plaintext highlighter-rouge">User template</code>. The Certify tool can be used to easily retrieve a valid PEM certificate. Once converted with openssl to a PFX, you can use it with Kekeo, Rubeus or Certipy to authenticate via PKINIT, retrieve a TGT and then the user’s NT hash.</p><video style="display:block; width:100%; height:auto;" autoplay="" controls="" loop="loop"> <source src="/assets/video/demo_tscon.mp4" type="video/mp4" /> </video> <center><u><i>Session hijacking via Certify and Tscon tools</i></u></center><p><br /></p><p>This method relies on legit features and allows to compromise a domain user without touching LSASS on a stealthier way (take care of the Certify binary detection). However, this technique was performed manually via an interactive session through RDP. This remains harder to be automated on a larger scope as the Lsassy / CME tools do by dumping the LSASS process memory through SMB.</p><p>After few attempts to develop a tool automating the usage of tscon and Certify via a “ducky script like strategy” (really bad idea btw), I thought about a way to impersonate on a large scale the users’ sessions that were not properly logged off on the remote servers.</p><p>The Windows token mechanisms came to my mind and in particular the use of the Incognito tool. Indeed, from an attacker point of view who is local administrator on a system, a privilege escalation could be perform to become <code class="language-plaintext highlighter-rouge">NT AUTHORITY/SYSTEM</code> (for instance via a service creation as PSEXEC do). Then, from this privileged access, all running processes on the compromised system can be browsed in order to open the one related to our targeted domain user. Once the process is opened, its associated access tokens can be duplicated and re-used to hijack the user session.</p><p>The advantage of this technique is that it automates the process of impersonating users and execute arbitrary code within their context. The following demo shows how it is possible, from a meterpreter session, to easily switch from one user context to another.</p><video style="display:block; width:100%; height:auto;" autoplay="" controls="" loop="loop"> <source src="/assets/video/demo_incognito.mp4" type="video/mp4" /> </video> <center><u><i>Demo of users' sessions switching via Incognito through token impersonation</i></u></center><p><br /></p><p>McAfee’s security team made <a href="https://www.mcafee.com/enterprise/en-us/assets/reports/rp-access-token-theft-manipulation-attacks.pdf">a very interesting article</a> about the theft and manipulation of these access tokens. In a nutshell, when a user logs on to a Windows system, a session represented by a Security Identifier (SID) is created. Moreover, an access token is generated by the Local Security Authority (LSA) and is associated with the user’s session. This token is used to describe the security context and privileges of the actual user (groups, etc.). Each process derived from the user’s session inherit of this access token. This allows the system to apply the correct restriction or authorization on the system for a running process (using primary token) or a thread (using impersonation token). Each of these tokens can have different <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-levels">impersonation levels</a> describing the actions that can be performed in the user’s context. The <code class="language-plaintext highlighter-rouge">SecurityDelegation</code> is especially useful because it allows to impersonate the user through the network, meaning that ADCS interactions could be performed.</p><p>This is once again a topic that would need tons of explaination to be fully covered. But, this mechanism answer to our actual need. Indeed, we are able to fully impersonate domain users’ authenticated on a compromised server, to request a certificate in their context and so to obtain for each of them a TGT and a NT hash.</p><blockquote class="prompt-tip"><p>While writting this article a <a href="https://research.ifcr.dk/certipy-4-0-esc9-esc10-bloodhound-gui-new-authentication-and-request-methods-and-more-7237d88061f7">new release (4.0)</a> of Certipy was made by Ly4k. From lots of new interesting features, the SSPI option was implemented. This allows to use the current user context on a Windows system to take advantage of the other modules without knowing the current user credentials.</p></blockquote><h2 id="putting-it-all-together"><span class="mr-2">Putting it all together</span><a href="#putting-it-all-together" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We now have all the elements in our hands! Based on all of these notions, I developed a tool called Masky that automates this process and works like Lsassy does. This tool is composed of a Python part running on the attacker’s system and an executable agent in C# deployed on targeted systems.</p><p>The following schema describes the implemented steps for a targeted host.</p><p><a href="/assets/img/masky-archi.png" class="popup img-link "><img data-src="/assets/img/masky-archi.png" alt="Overview of the Masky operating mode" class="lazyload" data-proofer-ignore></a></p><center><u><i>Overview of the Masky operating mode</i></u></center><p><br /></p><h3 id="step-1---deploy-and-run-masky-agent"><span class="mr-2">Step 1 - Deploy and run Masky agent</span><a href="#step-1---deploy-and-run-masky-agent" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>First, the attacker must own a user with local administrator privileges on the targeted systems. Masky supports plaintext password, NT hashes or Kerberos authentication with a loaded CCACHE file. In case of the exposure of the tcp port 445, an SMB connection is established.</p><p>This SMB session allows to push a Masky agent executable into the Windows Temp folder. Once successfuly pushed via the <code class="language-plaintext highlighter-rouge">C$</code> remote share, the <code class="language-plaintext highlighter-rouge">ImagePath</code> attribute related to the existing <code class="language-plaintext highlighter-rouge">RasAuto</code> service is modified to point on the Masky agent. I chose this method as it is stealthiest to modify an existing service property rather than creating a new one that will be deleted later. This remote code execution method was <a href="https://github.com/Hackndo/lsassy/blob/master/lsassy/exec/smb_stealth.py">implemented by Pixis in Lsassy</a> based on the <a href="https://twitter.com/Cyb3rSn0rlax">@Cyb3rSn0rlax</a> idea. The <a href="http://revertservice.com/7/rasauto/"><code class="language-plaintext highlighter-rouge">RasAuto</code></a> service was chosen because it is started manually and is deployed by default from older Windows versions to newer ones.</p><p>Finally, the modified service is started via the DCERPC Impacket implementation (SCMR) and the Masky agent is launched with <code class="language-plaintext highlighter-rouge">NT AUTHORITY/SYSTEM</code> privileges.</p><h3 id="steps-2-and-3---query-adcs-for-certificates"><span class="mr-2">Steps 2 and 3 - Query ADCS for certificates</span><a href="#steps-2-and-3---query-adcs-for-certificates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This binary, developed in C#, aims to browse all running processes. For each of them, it performs some checks like what kind of process it is or who is the owner. Then, the process is opened with the <code class="language-plaintext highlighter-rouge">OpenProcessToken</code> function to retrieve the associated access tokens. The tokens are duplicated with the <code class="language-plaintext highlighter-rouge">DuplicateTokenEx</code> function and finally the current impersonation token of the Masky agent main thread is replaced by the spoofed one with a call to <code class="language-plaintext highlighter-rouge">SetThreadToken</code>. These functions are members of the Win32API, their prototypes can be easily retrieved from the <a href="https://www.pinvoke.net/">Pinvoke website</a> to be used in C#.</p><p>For each spoofed user, an asymmetric key pair is generated and a CSR requesting the User template is sent to the CA server. This implementation is entirely based on the Certify tool. The PEM certificate is retrieved and appended within a JSON file with the spoofed username. The Masky agent switch between users by storing its initial access token and restoring it. This avoids to spawn processes or threads to perform this task.</p><p>Masky automatically downloads the generated JSON file through SMB as well as a debugging file (in case of a stacktrace). Finally, all files are deleted from the remote server and the <code class="language-plaintext highlighter-rouge">RasAuto</code> original <code class="language-plaintext highlighter-rouge">ImagePath</code> is restored.</p><h3 id="step-4---retrieve-users-secrets-from-downloaded-certificates"><span class="mr-2">Step 4 - Retrieve users’ secrets from downloaded certificates</span><a href="#step-4---retrieve-users-secrets-from-downloaded-certificates" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The next steps are performed from the local attacker’s system. Indeed, the collected PEM certificates are converted into PFX format and a TGT is requested to the KDC via the PKINIT Kerberos implementation. This TGT is exported in the CCACHE format to be easily loaded on Linux systems (via the command line: <code class="language-plaintext highlighter-rouge">export KRB5CCNAME=./file.ccache</code>). Then, a NT hash is retrieved through the PKINIT fallback feature. All of these KDC interactions came from the tools <a href="https://github.com/ly4k/Certipy">Certipy</a> and <a href="https://github.com/dirkjanm/PKINITtools">PKINITTools</a> (developed by <a href="https://twitter.com/_dirkjan">Dirk-jan Mollema</a>). Only minors modifications were made from the original Certipy modules in order to do this job!</p><p>This overall process is replicated on each targeted system to store locally the NT hashes, CCACHE and PFX files. All of this allowing to perform further Pass-The-(hash,ticket,certificate) lateral movements! :)</p><h2 id="masky-for-fun-and-profit"><span class="mr-2">Masky for fun and profit</span><a href="#masky-for-fun-and-profit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Masky version 0.0.3 was released besides this article on my github: <a href="https://github.com/Z4kSec/Masky">https://github.com/Z4kSec/Masky</a>.</p><blockquote class="prompt-warning"><p>This version might be “unstable” and special care should be taken while using it to ensure that the RasAuto ImagePath has been correctly restored on the targeted system, in case of an unexpected crash. This should not occured of course, but we never anticipate all behaviors! ;)</p></blockquote><p>Because a demo is sometimes more effective than lots of words, please find below an example of its use.</p><video style="display:block; width:100%; height:auto;" autoplay="" controls="" loop="loop"> <source src="/assets/video/demo_masky.mp4" type="video/mp4" /> </video> <center><u><i>Masky demo on a testing lab</i></u></center><p><br /></p><p>Note that the FQDN of the CA server and the CA names must be provided to the tool. The <code class="language-plaintext highlighter-rouge">User</code> template must also be enabled on it. This information can be easily retrieved with the <code class="language-plaintext highlighter-rouge">find</code> Certipy commands as well as via the <code class="language-plaintext highlighter-rouge">certutil.exe</code> Microsoft utility.</p><p>All parameters and their usage are described within the Masky Github readme. Moreover, the tool can be used as a library to be integrated within other tools.</p><p>Below is a simple script using the Masky library to collect secrets of running domain user’s sessions, from a remote target.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">masky</span> <span class="kn">import</span> <span class="n">Masky</span>
<span class="kn">from</span> <span class="n">getpass</span> <span class="kn">import</span> <span class="n">getpass</span>


<span class="k">def</span> <span class="nf">dump_nt_hashes</span><span class="p">():</span>
    <span class="c1"># Define the authentication parameters
</span>    <span class="n">ca</span> <span class="o">=</span> <span class="sh">"</span><span class="s">srv-01.sec.lab\sec-SRV-01-CA</span><span class="sh">"</span>
    <span class="n">dc_ip</span> <span class="o">=</span> <span class="sh">"</span><span class="s">192.168.23.148</span><span class="sh">"</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="sh">"</span><span class="s">sec.lab</span><span class="sh">"</span>
    <span class="n">user</span> <span class="o">=</span> <span class="sh">"</span><span class="s">askywalker</span><span class="sh">"</span>
    <span class="n">password</span> <span class="o">=</span> <span class="nf">getpass</span><span class="p">()</span>

    <span class="c1"># Create a Masky instance with these credentials
</span>    <span class="n">m</span> <span class="o">=</span> <span class="nc">Masky</span><span class="p">(</span><span class="n">ca</span><span class="o">=</span><span class="n">ca</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">user</span><span class="p">,</span> <span class="n">dc_ip</span><span class="o">=</span><span class="n">dc_ip</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">)</span>

    <span class="c1"># Set a target and run Masky against it
</span>    <span class="n">target</span> <span class="o">=</span> <span class="sh">"</span><span class="s">192.168.23.130</span><span class="sh">"</span>
    <span class="n">rslts</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="c1"># Check if Masky succesfully hijacked at least a user session
</span>    <span class="c1"># or if an unexpected error occured
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">rslts</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c1"># Loop on MaskyResult object to display hijacked users and to retreive their NT hashes
</span>    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Results from hostname: </span><span class="si">{</span><span class="n">rslts</span><span class="p">.</span><span class="n">hostname</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">rslts</span><span class="p">.</span><span class="n">users</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\t</span><span class="s"> - </span><span class="si">{</span><span class="n">user</span><span class="p">.</span><span class="n">domain</span><span class="si">}</span><span class="s">\{user.name} - </span><span class="si">{</span><span class="n">user</span><span class="p">.</span><span class="n">nt_hash</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">dump_nt_hashes</span><span class="p">()</span>
</pre></table></code></div></div><p>This generates the following output once executed on my testing lab.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>$&gt; python3 ./masky_demo.py
Password:
Results from hostname: SRV-01
         - sec\hsolo - 05ff4b2d523bc5c21e195e9851e2b157
         - sec\askywalker - 8928e0723012a8471c0084149c4e23b1
         - sec\administrator - 4f1c6b554bb79e2ce91e012ffbe6988a
</pre></table></code></div></div><p>A <code class="language-plaintext highlighter-rouge">MaskyResults</code> object containing a list of <code class="language-plaintext highlighter-rouge">User</code> objects is returned after a successful execution of Masky.</p><p>Please look at the <code class="language-plaintext highlighter-rouge">masky\lib\results.py</code> module to check the methods and attributes provided by these two classes.</p><h2 id="detection-vectors"><span class="mr-2">Detection vectors</span><a href="#detection-vectors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>From a blueteam perspective, several behaviors can be detected when exploiting such attack path.</p><p>First of all, Masky heavily relies on the SMB protocol to execute remote code on the target, but also to deploy the agent and retrieves the results.</p><p>Offensive tools relying on this protocol typically interact with three shares: <code class="language-plaintext highlighter-rouge">C$</code>, <code class="language-plaintext highlighter-rouge">ADMIN$</code> and <code class="language-plaintext highlighter-rouge">IPC$</code>. Wherever the C$ and ADMIN$ shares are mounted as local administrator and are used to push or retrieve files, the IPC$ is related to the usage of named pipes exposed by the remote system. It basically allows to interact with the features exposed on the target through legitimate protocols. Indeed, the <code class="language-plaintext highlighter-rouge">DCERPC</code> protocol allows, as it names suggest, to call remote procedures allowing for example to create services (via <code class="language-plaintext highlighter-rouge">\pipe\svcctl</code>) or scheduled tasks (via <code class="language-plaintext highlighter-rouge">\pipe\atsvc</code>). I strongly recommend diving into Impacket source code and especially their example scripts to understand how it works (smbexec.py, atexec.py, etc.).</p><p>From this information, the following Windows event log IDs can be collected on your SIEM to create detection rules for such remote code execution over SMB:</p><ul><li><code class="language-plaintext highlighter-rouge">4698</code>: A schedule task was created;<li><code class="language-plaintext highlighter-rouge">4699</code>: A schedule task was deleted;<li><code class="language-plaintext highlighter-rouge">4702</code>: A schedule task was updated;<li><code class="language-plaintext highlighter-rouge">7045</code>: A new service was created;<li><code class="language-plaintext highlighter-rouge">5145</code>: A network share object (file or folder) was accessed.</ul><p>The use of service or schedule tasks in a short period of time (e.g. creation, modification or deletion) could be an interesting weak signal to correlate with administrative shares interactions (C$ / ADMIN$), as well as the IPC$ special share. Indeed, this could be a sign of the use of such lateral movement techniques. False positives can occur based on these rules depending on the administration tools used through the corporate LAN (e.g. PSEXEC). To go deeper in such detection, rules can be combined to identify the spawning of suspicious lolbins, unsigned binaries or commonly executed recognition commands (e.g. whoami, net user, etc.) from the process tree of the <code class="language-plaintext highlighter-rouge">schtasks.exe</code> (schedule tasks) or <code class="language-plaintext highlighter-rouge">winexesvc.exe</code> (services) processes.</p><p>Once the lateral movement detection is monitored, the behaviors related to the locally deployed agent has to be handled.</p><p>The token impersonation part may be difficult to be detected due to the usage of legitimate built-in Microsoft Win32API functions. The McAfee’s article includes a diagram that sum-up the call of such functions during a token impersonation attempts.</p><p><a href="/assets/img/win32API_tokens.png" class="popup img-link "><img data-src="/assets/img/win32API_tokens.png" alt="McAfee's schema which sum-up the functions involved in token impersonation attack" class="lazyload" data-proofer-ignore></a></p><center><u><i>McAfee's schema which sum-up the functions involved in token impersonation attack</i></u></center><p><br /></p><p>In Masky case, the <code class="language-plaintext highlighter-rouge">OpenProcessToken</code>, <code class="language-plaintext highlighter-rouge">DuplicateTokenEx</code> and <code class="language-plaintext highlighter-rouge">SetThreadToken</code> are primarily used to perform session hijacking on active users. A Yara rule dedicated to the detection of malwares relying on such Win32API functions was written within the quoted McAfee article and could be a good start. Note that this detection method is more related to static analaysis during incident response. Without an in-depth manual analysis, such automated detection could be bypassed by an attacker applying techniques such as obfuscation, packing, process hollowing with dynamic unxor of the payload, etc.</p><p>In addition, the interaction with the ADCS instance could be an interesting way to detect Masky execution. The <a href="https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf">Certified Pre-Owned</a> article describes detection and preventive actions that could be applied on ADCS environment. From the listed detection methods, the one referenced <code class="language-plaintext highlighter-rouge">DETECT1</code> recommends to monitor the users’ certificates enrollement via the Event ID <code class="language-plaintext highlighter-rouge">4886</code> (“Certificate Services received a certificate request”) and their approval via the Event ID <code class="language-plaintext highlighter-rouge">4887</code> (“Certificate Services approved a certificate request and issued a certificate”). However, depending on the environment, the monitoring of all certificate requests could not be efficient when there is a large number of legitimate requests.</p><p>A second method that could generate less false positive detection is suggested by the Specterops team. Referenced <code class="language-plaintext highlighter-rouge">DETECT2</code>, this detection method is based on the identification of Kerberos authentication made via a certificate, through PKINIT. Indeed, the Event ID <code class="language-plaintext highlighter-rouge">4768</code> (“A kerberos authentication ticket (TGT) was requested”) is generated on the KDC server. When a TGT is queried with a certificate, this event log contains 3 new fields in the <code class="language-plaintext highlighter-rouge">Certificate Information</code> section (<code class="language-plaintext highlighter-rouge">Issuer</code>, <code class="language-plaintext highlighter-rouge">Serial Number</code> and <code class="language-plaintext highlighter-rouge">Thumbprint</code>). Modern environments less use this protocol, and could therefore allow to detect malicious authentication attempts with a previously obtained certificate.</p><p>Finally, in case of a widespread Masky usage, the deployed agent may be automatically detected via a static analysis by common EPP or EDR if used as part of the PyPi package (embedded agent executable).</p><h2 id="whats-next"><span class="mr-2">What’s next?</span><a href="#whats-next" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>First, an optimization of the token impersonation harvesting within the Masky Agent has to be done. Then, lots of debugging may be performed regarding unexpected bugs based on other environments than my lab.</p><p>The published version actually includes minimal functionnalties to be used in pentesting engagements.</p><p>However, I planned to implement the following features:</p><ul><li>Ability to dynamically change the modified service (default <code class="language-plaintext highlighter-rouge">RasAuto</code>);<li>Option to automatically retrieve the CA server and look for the User template;<li>Add multiple execution methods through SMB (schedule task, WMI, creation of service, etc.);<li>Deploy the Masky agent as a XORed payload (with a random key) and dynamically load it through a <code class="language-plaintext highlighter-rouge">svchost.exe</code> launched process (process hollowing technique).</ul><p>A <a href="https://github.com/Porchetta-Industries/CrackMapExec">CrackMapExec</a> module could also be developed if Masky has some interest for the info sec community :)</p><h2 id="acknowledgements"><span class="mr-2">Acknowledgements</span><a href="#acknowledgements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://twitter.com/ly4k_">Olivier Lyak</a> for the <a href="https://github.com/ly4k/Certipy">Certipy</a> tool and the <a href="https://medium.com/@oliverlyak">associated articles</a><li><a href="https://twitter.com/harmj0y">Will Schroeder</a> and <a href="https://twitter.com/tifkin_">Lee Christensen</a> for the <a href="https://github.com/GhostPack/Certify">Certify</a> tool and the <a href="https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf">Certified Pre-Owned</a> article<li><a href="https://twitter.com/_dirkjan">Dirk-jan</a> for the <a href="https://github.com/dirkjanm/PKINITtools">PKINITtools</a> and its <a href="https://dirkjanm.io/ntlm-relaying-to-ad-certificate-services/">ADCS NTLM relay</a> article<li><a href="https://github.com/SecureAuthCorp">SecureAuthCorp</a> and the associated contributors for the <a href="https://github.com/SecureAuthCorp/impacket">Impacket</a> library<li><a href="https://twitter.com/HackAndDo">Pixis</a> for the tool <a href="https://github.com/Hackndo/Lsassy">Lsassy</a><li>Incognito tool and its <a href="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/extensions/incognito/">Metasploit implementation</a><li><a href="https://twitter.com/ShitSecure">S3cur3Th1sSh1t</a> for the tool <a href="https://github.com/S3cur3Th1sSh1t/SharpImpersonation">SharpImpersonation</a> and the <a href="https://s3cur3th1ssh1t.github.io/SharpImpersonation-Introduction/">associated article</a><li>McAfee for their article regarding the <a href="https://www.mcafee.com/enterprise/en-us/assets/reports/rp-access-token-theft-manipulation-attacks.pdf">token impersonation techniques</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tools/'>Tools</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/masky/" class="post-tag no-text-decoration" >masky</a> <a href="/tags/adcs/" class="post-tag no-text-decoration" >adcs</a> <a href="/tags/tool/" class="post-tag no-text-decoration" >tool</a> <a href="/tags/dump/" class="post-tag no-text-decoration" >dump</a> <a href="/tags/ad/" class="post-tag no-text-decoration" >AD</a> <a href="/tags/pentest/" class="post-tag no-text-decoration" >pentest</a> <a href="/tags/lsass/" class="post-tag no-text-decoration" >lsass</a> <a href="/tags/certificates/" class="post-tag no-text-decoration" >certificates</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Masky%20release%20(v0.0.3)%20-%20Zak's%20blog&url=https%3A%2F%2Fz4ksec.github.io%2Fposts%2Fmasky-release-v0.0.3%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Masky%20release%20(v0.0.3)%20-%20Zak's%20blog&u=https%3A%2F%2Fz4ksec.github.io%2Fposts%2Fmasky-release-v0.0.3%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fz4ksec.github.io%2Fposts%2Fmasky-release-v0.0.3%2F&text=Masky%20release%20(v0.0.3)%20-%20Zak's%20blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ioctlhunter-release-v0.2/">IoctlHunter Release (v0.2)</a><li><a href="/posts/masky-release-v0.0.3/">Masky release (v0.0.3)</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/pentest/">pentest</a> <a class="post-tag" href="/tags/ad/">AD</a> <a class="post-tag" href="/tags/adcs/">adcs</a> <a class="post-tag" href="/tags/certificates/">certificates</a> <a class="post-tag" href="/tags/drivers/">drivers</a> <a class="post-tag" href="/tags/dump/">dump</a> <a class="post-tag" href="/tags/frida/">frida</a> <a class="post-tag" href="/tags/ioctl/">ioctl</a> <a class="post-tag" href="/tags/ioctlhunter/">ioctlhunter</a> <a class="post-tag" href="/tags/lsass/">lsass</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/ioctlhunter-release-v0.2/"><div class="card-body"> <em class="small" data-ts="1701907200" data-df="ll" > Dec 7, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IoctlHunter Release (v0.2)</h3><div class="text-muted small"><p> A Bit of Context IoctlHunter is a command-line tool designed to simplify the analysis of IOCTL calls made by userland software targeting Windows drivers. TL;DR: Here are the videos demonstrating ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"><div class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></div><a href="/posts/ioctlhunter-release-v0.2/" class="btn btn-outline-primary" prompt="Newer"><p>IoctlHunter Release (v0.2)</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/pentest/">pentest</a> <a class="post-tag" href="/tags/ad/">AD</a> <a class="post-tag" href="/tags/adcs/">adcs</a> <a class="post-tag" href="/tags/certificates/">certificates</a> <a class="post-tag" href="/tags/drivers/">drivers</a> <a class="post-tag" href="/tags/dump/">dump</a> <a class="post-tag" href="/tags/frida/">frida</a> <a class="post-tag" href="/tags/ioctl/">ioctl</a> <a class="post-tag" href="/tags/ioctlhunter/">ioctlhunter</a> <a class="post-tag" href="/tags/lsass/">lsass</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/_ZakSec">Zak</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
